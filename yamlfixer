#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""# yamlfixer
yamlfixer automates the fixing of problems reported by
[yamllint](https://github.com/adrienverge/yamllint) by parsing its
output.

# Usage
This software automatically fixes some errors and warnings reported by
_yamllint_.

usage:

```
$ yamlfixer [--debug] [--verbose] [--backup] *.yml - thisfile.yaml
```

or:

```
$ yamlfixer [--help] [--version]
```

This will launch _yamllint_ on each specified file name (`-` is _stdin_),
then parse its output and try to fix the reported problems.

If input is read from _stdin_, the corrected output will be sent to
_stdout_. Other files will be overwritten if needed. Original files,
_stdin_ excepted, can be preserved as _.orig_ if the _--backup_
command line option is used.

Diagnostic information is sent to stderr in verbose or debug modes.

This command exits with `0` if all input files either are skipped or
successfully pass _yamllint_ strict mode, else `-1`.

**IMPORTANT:** Not all problems are fixable by _yamlfixer_. Due to the
way _yamllint_ works, it doesn't currenlty report all faulty lines,
_yamlfixer_ might even introduce indentation problems under some
circumstances.
**Use at your own risk, you have been warned...**

# Licensing information
Copyright (C) 2021 OPT-NC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Contact

OPT-NC, aka _Office des Postes et Télécommunications de Nouvelle-Calédonie_,
has a corporate website on [www.opt.nc](https://www.opt.nc)

You can contact the author of this software at
[jerome.alet@opt.nc](mailto:jerome.alet@opt.nc)
"""

import sys
import os
import subprocess

VERSION = '0.1'

LINTERCOMMAND = 'yamllint --format parsable --strict -'

FIX_PASSEDLINTER = 0
FIX_MODIFIED = 1
FIX_UNMODIFIED = 2
FIX_SKIPPED = 3
FIX_PERMERROR = 4

FIXER_UNHANDLED = -1
FIXER_HANDLED = 0

class ProblemFixer:
    """To hold problem fixing logic."""
    fixers = {}
    def __init__(self, filefixer, linenum, colnum, problem):
        """Intializes a problem fixer."""
        self.ffixer = filefixer
        self.linenum = linenum + self.ffixer.loffset - 1
        self.colnum = colnum + self.ffixer.coffset - 1
        self.problem = problem
        if not self.fixers:
            for methodname in [m for m in dir(self) if m.startswith('fix_')]:
                docstring = getattr(self, methodname).__doc__
                for prob in [pb.strip()[2:] for pb in docstring.splitlines()[1:]]:
                    if prob:
                        self.fixers[prob] = methodname

    def __call__(self):
        """Make it callable."""
        for (fixerkey, methodname) in self.fixers.items():
            if self.problem.startswith(fixerkey):
                # pylint: disable=line-too-long
                self.ffixer.yfixer.debug(f"Calling {methodname} because [{fixerkey}] matches [{self.problem}]")
                line = self.ffixer.lines[self.linenum]
                left = line[:self.colnum]
                right = line[self.colnum:]
                getattr(self, methodname)(left, right)
                return FIXER_HANDLED
        self.ffixer.yfixer.debug(f"No handler found for [{self.problem}]")
        return FIXER_UNHANDLED

    def get_indentation(self, offset):
        """Returns the indentation of the current (possibly offset) line."""
        line = self.ffixer.lines[self.linenum + offset]
        return len(line) - len(line.lstrip())

    #
    # Fixing code below.
    #
    # To fix a new kind of problem, simply add a fix_whatever method
    # and ensure its docstring is formatted the same way as the
    # existing ones. Each docstring lists each problem its method
    # should fix, exactly as it is reported by yamllint. Matching is
    # done from the beginning of yamllint's output after the
    # warning/error level.
    #

    def fix_missing_docstart(self, left, right): # pylint: disable=unused-argument
        """Fix:
             - missing document start
        """
        self.ffixer.lines.insert(0, '---')
        self.ffixer.loffset += 1

    def fix_newlineateof(self, left, right): # pylint: disable=unused-argument,no-self-use
        """Fix:
             - no new line character at the end of file
        """
        # We simply ignore it, because we always add \n when dumping.

    def fix_truthy(self, left, right):
        """Fix:
             - truthy value should be one of [false, true] (truthy)
        """
        for trueval in ('on', 'yes', 'true'):
            if right.lower().startswith(trueval):
                self.ffixer.lines[self.linenum] = left + 'true' + right[len(trueval):]
                self.ffixer.coffset += len('true') - len(trueval)
                return
        for falseval in ('off', 'no', 'false'):
            if right.lower().startswith(falseval):
                self.ffixer.lines[self.linenum] = left + 'false' + right[len(falseval):]
                self.ffixer.coffset += len('false') - len(falseval)
                return

    def fix_toofew_spacesbefore(self, left, right):
        """Fix:
             - too few spaces before comment (comments)
        """
        spaces = ' '
        if left[-1] != ' ':
            spaces += ' '
        self.ffixer.lines[self.linenum] = left + spaces + right
        self.ffixer.coffset += len(spaces)

    def fix_trailingspaces(self, left, right):
        """Fix:
             - trailing spaces (trailing-spaces)
        """
        # No need to adjust coffset because we are at EOL by definition
        self.ffixer.lines[self.linenum] = (left + right).rstrip()

    def fix_toomany_blanklines(self, left, right): # pylint: disable=unused-argument
        """Fix:
             - too many blank lines
        """
        parts = self.problem.split()
        blanklines = int(parts[4][1:])
        maxblanklines = int(parts[6].split(')')[0])
        nblines = blanklines - maxblanklines
        del self.ffixer.lines[self.linenum - nblines + 1:self.linenum + 1]
        self.ffixer.loffset -= nblines

    def fix_syntax_tabchar(self, left, right):
        """Fix:
             - syntax error: found character '\\t' that cannot start any token (syntax)
        """
        # TODO: We replace TAB with a single space for now
        # TODO: yamllint only reports the first one
        # TODO: use expandtabs after reading indentation size from .yamllint if possible
        self.ffixer.lines[self.linenum] = left + ' ' + right[1:]

    def fix_missingspace(self, left, right):
        """Fix:
             - missing starting space in comment (comments)
             - too few spaces after comma (commas)
        """
        self.ffixer.lines[self.linenum] = left + ' ' + right
        self.ffixer.coffset += 1

    def fix_toomany_spacesafter(self, left, right):
        """Fix:
             - too many spaces after colon (colons)
             - too many spaces after comma (commas)
             - too many spaces after hyphen (hyphens)
        """
        pos = self.colnum
        while (pos > 0) and (left[pos - 1] == ' '):
            pos -= 1
        self.ffixer.lines[self.linenum] = left[:pos] + right
        self.ffixer.coffset -= (self.colnum - pos)

    def fix_toomany_spacesother(self, left, right):
        """Fix:
             - too many spaces inside braces (braces)
             - too many spaces inside brackets (brackets)
             - too many spaces before comma (commas)
             - too many spaces before colon (colons)
        """
        pos = self.colnum
        while (pos > 0) and (left[pos - 1] == ' '):
            pos -= 1
        self.ffixer.lines[self.linenum] = left[:pos] + right[1:]
        self.ffixer.coffset -= (self.colnum - pos + 1)

    def fix_comment_notindentedlike(self, left, right):
        """Fix:
             - comment not indented like content (comments-indentation)
        """
        if self.linenum > 0:
            indentation = self.get_indentation(-1)
            # If previous line is similarly indented then use indentation of next line
            if indentation == self.colnum:
                indentation = self.get_indentation(+1)
        else:
            indentation = self.get_indentation(+1)
        self.ffixer.lines[self.linenum] = ' ' * indentation + (left + right).lstrip()
        self.ffixer.coffset += (indentation - self.colnum)

    def fix_wrong_indentation(self, left, right):
        """Fix:
             - wrong indentation: expected
        """
        # TODO: yamllint only reports the first faulty line in a block :-(
        # TODO: see https://github.com/adrienverge/yamllint/issues/427
        # TODO: we fix anyway, knowing that we may need to launch the command
        # TODO: several times to finally fix the problem.
        parts = self.problem.split()
        expected = int(parts[3])
        found = int(parts[6])
        offset = expected - found
        if expected > found:
            self.ffixer.lines[self.linenum] = (' ' * offset) + left + right
        else:
            # expected < found because we woudln't be there otherwise anyway
            self.ffixer.lines[self.linenum] = (left + right)[-offset:]
        self.ffixer.coffset += offset

    def fix_linetoolong(self, left, right): # pylint: disable=unused-argument
        """Fix:
             - line too long
        """
        # TODO: currently we fix this by disabling the error in yamllint, it's the easiest way
        self.ffixer.lines.insert(self.linenum, ' ' * self.get_indentation(0) \
                             + '# yamllint disable-line rule:line-length')
        self.ffixer.loffset += 1


class FileFixer:
    """To hold file fixing logic."""
    def __init__(self, yamlfixer, filename):
        """Initialize a file to fix."""
        self.yfixer = yamlfixer
        self.filename = filename
        self.loffset = self.coffset = 0
        self.shebang = ''
        self.incontents = None
        self.lines = []

    def canonicalizeproblems(self, linteroutput):
        """Create a nested mapping of lines and columns to fix."""
        problemlines = {}
        for line in linteroutput.splitlines():
            (_, linenumber, colnumber, message) = line.split(':', 3)
            (_, msg) = message.strip().split(' ', 1)
            colstofix = problemlines.setdefault(int(linenumber), {})
            # On a given line, there could be several problems on the same column
            coltofix = colstofix.setdefault(int(colnumber), [])
            coltofix.append(msg)

        # If there's a shebang line we ignore it and any problem reported on it
        if (self.incontents is not None) and self.incontents.startswith('#!'):
            eolpos = self.incontents.find('\n') + 1
            self.shebang = self.incontents[:eolpos]
            self.incontents = self.incontents[eolpos:]
            try:
                del problemlines[1]
            except KeyError:
                pass # No problem reported on shebang line by yamllint
            # This line won't ever see the fixer so all subsequent lines must be offset by -1
            self.loffset = -1

        return problemlines

    def lint(self):
        """Launches the linter on a file's contents.

           Returns the (linter's exitcode, linter's stdout) tuple.
        """
        linter = subprocess.run(LINTERCOMMAND,
                                shell=True,
                                capture_output=True,
                                text=True,
                                check=False,
                                input=self.incontents,
                                encoding='utf-8')
        return (linter.returncode, linter.stdout)

    def load(self):
        """Loads the input file's contents."""
        if self.filename == '-':
            self.incontents = sys.stdin.read()
        else:
            try:
                with open(self.filename, 'r') as yamlfile:
                    self.incontents = yamlfile.read()
            except FileNotFoundError as msg:
                self.yfixer.error(f"{msg}")

    def dump(self, outcontents):
        """Dumps the new file's contents."""
        if (self.incontents is None) or (outcontents == self.incontents):
            retcode = FIX_SKIPPED
        else:
            retcode = FIX_MODIFIED
        if self.filename == '-': # Always dump to stdout in this case
            sys.stdout.write(self.shebang + (outcontents or ''))
            sys.stdout.flush()
        elif retcode == FIX_MODIFIED: # Don't write unnecessarily
            try:
                if self.yfixer.backupmode: # pylint: disable=no-member
                    # Try to make a backup of the original file
                    try:
                        os.replace(self.filename, f"{self.filename}.orig")
                    except PermissionError as msg:
                        self.yfixer.error(f"impossible to create a backup : {msg}")
                # Overwrite the original file with the new contents
                with open(self.filename, 'w') as yamlfile:
                    yamlfile.write(self.shebang + (outcontents or ''))
            except PermissionError as msg:
                self.yfixer.error(f"impossible to save fixed contents : {msg}")
                retcode = FIX_PERMERROR
        return retcode

    def fix(self):
        """Fix a file's contents."""
        # Load the file's contents in memory
        self.load()

        # Skip that file if we don't want to modify it
        if (self.incontents is None) or self.incontents.startswith('$ANSIBLE_VAULT;'):
            return self.dump(self.incontents)

        # Lint the file's contents
        (ltexitcode, ltstdout) = self.lint()
        if not ltexitcode:
            self.dump(self.incontents)
            return FIX_PASSEDLINTER

        # Organize the set of problems to fix
        linestofix = self.canonicalizeproblems(ltstdout)

        # Now handle each of the problems reported by yamllint
        self.lines = self.incontents.splitlines()
        for linenumber in sorted(linestofix.keys()):
            self.coffset = 0
            for colnumber in sorted(linestofix[linenumber].keys()):
                for problem in linestofix[linenumber][colnumber]:
                    # pylint: disable=line-too-long
                    debuginfo = f"({linenumber}, {colnumber})/({self.loffset}, {self.coffset}) => {problem}"
                    handled = ProblemFixer(self, linenumber, colnumber, problem)()
                    # pylint: disable=line-too-long
                    self.yfixer.debug(f"{((handled == FIXER_HANDLED) and 'HANDLED') or 'UNHANDLED'}: {debuginfo}")
        return self.dump('\n'.join(self.lines) + '\n')


class YAMLFixer:
    """To hold files fixing logic."""
    def __init__(self, arguments):
        """Initialize the fixer for all files."""
        for mode in ('verbose', 'debug', 'backup'):
            attribute = f"{mode}mode"
            option = f"--{mode}"
            if option in arguments:
                setattr(self, attribute, True)
                arguments.remove(option)
            else:
                setattr(self, attribute, False)
        self.filenames = arguments
        if not self.filenames:
            self.filenames.append("-") # Add fake input from stdin
        self.passed = self.modified \
            = self.unmodified \
            = self.skipped \
            = self.permerrors \
            = self.unknown = 0

    def info(self, message, newline=True):
        """Output an informational message to stderr if verbose mode is active."""
        if self.verbosemode: # pylint: disable=no-member
            sys.stderr.write(f"{message}")
            if newline:
                sys.stderr.write('\n')

    def debug(self, message):
        """Output a debug message to stderr if debug mode is active."""
        if self.debugmode: # pylint: disable=no-member
            sys.stderr.write(f"DEBUG: {message}\n")

    def error(self, message): # pylint: disable=no-self-use
        """Output an error message to stderr."""
        sys.stderr.write(f"ERROR: {message}\n")

    def statistics(self):
        """Output some statistics."""
        self.info(f"Files to fix: {len(self.filenames)}")
        self.info(f"{self.passed} files successfully passed yamllint strict mode")
        self.info(f"{self.modified} files were modified")
        self.info(f"{self.unmodified} files were left unmodified")
        self.info(f"{self.skipped} files were skipped")
        self.info(f"{self.permerrors} files were not writeable")
        self.info(f"{self.unknown} files with unknown status")

    def fix(self):
        """Fix all files."""
        for filename in self.filenames:
            if filename == '-':
                absfilename = '<stdin>'
            else:
                absfilename = os.path.abspath(filename)
            filetofix = FileFixer(self, filename)
            # pylint: disable=no-member
            self.info(f"Fixing {absfilename} ... ", newline=False or self.debugmode)
            status = filetofix.fix()
            if status == FIX_PASSEDLINTER:
                self.info(f"passed linter's strict mode.")
                self.passed += 1
            elif status == FIX_MODIFIED:
                self.info(f"was modified.")
                self.modified += 1
            elif status == FIX_UNMODIFIED:
                self.info(f"was left unmodified.")
                self.unmodified += 1
            elif status == FIX_SKIPPED:
                self.info(f"was skipped.")
                self.skipped += 1
            elif status == FIX_PERMERROR:
                self.info(f"was not writeable.")
                self.permerrors += 1
            else:
                self.error(f"unknown fixing status [{status}]")
                self.unknown += 1

        self.statistics()
        if (self.passed + self.skipped) == len(self.filenames):
            return 0
        return -1

def main(arguments):
    """Main function."""
    if '--help' in arguments:
        print(__doc__)
        return 0
    if '--version' in arguments:
        print(f"yamlfixer v{VERSION}")
        return 0
    fixer = YAMLFixer(arguments)
    return fixer.fix()

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
